# 仕様駆動開発（SDD）

## パワーの逆転

何十年もの間、コードが王様でした。仕様はコードに従属し、開発の「本番作業」が始まると捨てられる足場のようなものでした。私たちはPRD（製品要件文書）を書き、設計ドキュメントを作り、アーキテクチャ図を描きましたが、それらは常にコードの下位に位置づけられていました。コードこそが真実であり、他のものはせいぜい善意に過ぎませんでした。コードが進化するにつれ、それが唯一のソース・オブ・トゥルースとなり、仕様はほとんど追いつけませんでした。資産（コード）と実装が一体化しているため、コードから構築しない限り並行した実装を持つのは困難でした。

仕様駆動開発（SDD）はこのパワー構造を逆転させます。仕様がコードに従うのではなく、コードが仕様に従います。PRD（製品要件仕様）は実装のガイドではなく、実装を生み出す源泉です。技術計画はコーディングを補助する文書ではなく、コードを生み出す精密な定義です。これはソフトウェア開発の漸進的な改善ではなく、開発を駆動するものそのものを根本から再考するものです。

仕様と実装のギャップは、ソフトウェア開発の黎明期から悩みの種でした。より良いドキュメント、詳細な要件、厳格なプロセスで橋渡ししようとしましたが、これらのアプローチはギャップを不可避なものとして受け入れているため、決して解消できませんでした。SDDは、仕様とそこから生まれる具体的な実装計画を実行可能にすることで、このギャップを消し去ります。仕様から実装計画、そしてコードが生成されるとき、そこにギャップはなく、ただ「変換」があるだけです。

この変革は、AIが複雑な仕様を理解し、詳細な実装計画を作成できるようになった今、初めて可能になりました。しかし、構造のないAI生成は混沌を生みます。SDDは、仕様とそれに続く実装計画を通じて、動作するシステムを生成するのに十分な精度・完全性・曖昧さのない構造を提供します。仕様が主たる成果物となり、コードは（実装計画からの）特定の言語やフレームワークでの表現となります。

この新しい世界では、ソフトウェアの保守とは仕様の進化を意味します。開発チームの意図は自然言語（「**意図駆動開発**」）、設計資産、コア原則、その他のガイドラインで表現されます。開発の**共通言語**はより高次元へと移行し、コードは「ラストマイル」の手段となります。

デバッグとは、誤ったコードを生み出す仕様や実装計画を修正することです。リファクタリングは明確さのための再構成です。開発ワークフロー全体が、仕様を中心としたソース・オブ・トゥルースとして再編成され、実装計画とコードは継続的に再生成されるアウトプットとなります。新機能の追加や新たな並行実装の作成は、仕様の見直しと新たな実装計画の作成を意味します。このプロセスは0→1、（1'、..）、2、3、Nと進化します。

開発チームは創造性、実験、クリティカルシンキングに集中できます。


## SDDワークフローの実際


ワークフローは、しばしば曖昧で不完全なアイデアから始まります。AIとの反復的な対話を通じて、このアイデアは包括的なPRDへと進化します。AIは明確化の質問を投げかけ、エッジケースを特定し、正確な受け入れ基準の定義を支援します。従来の開発で数日かかる会議やドキュメント作成が、数時間の集中的な仕様作成で完了します。これにより、従来のSDLC（ソフトウェア開発ライフサイクル）は変革され、要件定義と設計が離散的なフェーズではなく継続的な活動となります。これは**チームプロセス**を支援し、チームでレビューされた仕様がブランチで作成・バージョン管理・マージされます。

プロダクトマネージャーが受け入れ基準を更新すると、実装計画は自動的に影響を受ける技術的決定をフラグ付けします。アーキテクトがより良いパターンを発見した場合、PRDは新たな可能性を反映して更新されます。

この仕様作成プロセス全体で、リサーチエージェントが重要なコンテキストを収集します。ライブラリの互換性、パフォーマンスベンチマーク、セキュリティへの影響などを調査します。組織の制約も自動的に発見・適用され、会社のデータベース標準、認証要件、デプロイメントポリシーがすべての仕様にシームレスに統合されます。

PRDから、AIは要件を技術的決定にマッピングする実装計画を生成します。すべての技術選定には文書化された根拠があり、すべてのアーキテクチャ上の決定は特定の要件に遡ることができます。このプロセス全体で、一貫性の検証が継続的に品質を向上させます。AIは仕様の曖昧さ、矛盾、ギャップを一度きりのゲートではなく、継続的な改善として分析します。

仕様と実装計画が十分に安定した時点でコード生成が始まりますが、「完成」している必要はありません。初期の生成は探索的なものかもしれません—仕様が実際に意味をなすかどうかをテストします。ドメイン概念はデータモデルとなり、ユーザーストーリーはAPIエンドポイントとなり、受け入れシナリオはテストとなります。これにより、仕様を通じて開発とテストが統合され、テストシナリオはコードの後に書かれるのではなく、実装とテストの両方を生成する仕様の一部となります。

フィードバックループは初期開発を超えて広がります。プロダクションのメトリクスやインシデントは単なるホットフィックスを引き起こすだけでなく、次回の再生成に向けて仕様を更新します。パフォーマンスのボトルネックは新たな非機能要件となり、セキュリティ脆弱性は今後のすべての生成に影響する制約となります。仕様・実装・運用現実の間で繰り返されるこの反復的なダンスこそが、真の理解を生み出し、従来のSDLCを継続的進化へと変貌させます。


## なぜ今SDDが重要なのか


SDDが今、単に可能なだけでなく必要不可欠となった理由は3つあります：

第一に、AIの能力が自然言語の仕様から確実に動作するコードを生成できるレベルに到達したことです。これは開発者を置き換えることではなく、仕様から実装への機械的な変換を自動化することで彼らの効果を増幅することです。探索や創造性を拡張し、「やり直し」も容易にサポートし、加減算やクリティカルシンキングも支援します。

第二に、ソフトウェアの複雑さが指数関数的に増大し続けていることです。現代のシステムは数十のサービス、フレームワーク、依存関係を統合しています。これらすべてを手作業で元の意図に合わせ続けるのはますます困難です。SDDは仕様駆動の生成によって体系的な整合性を提供します。フレームワークもAIファーストなサポートや再利用可能なコンポーネント中心のアーキテクチャへと進化するかもしれません。

第三に、変化のペースが加速していることです。要件はかつてないほど急速に変化します。ピボットはもはや例外ではなく、当然のことです。現代のプロダクト開発はユーザーのフィードバック、市場状況、競争圧力に基づく迅速な反復を要求します。従来の開発はこれらの変化を混乱として扱い、各ピボットごとにドキュメント・設計・コードへの手動伝播が必要となります。その結果、速度を制限する慎重な更新か、技術的負債を蓄積する無謀な変更のいずれかになります。

SDDは「もしも/シミュレーション」実験もサポートできます。「もっとTシャツを売るためにアプリを再実装・変更する必要がある場合、どのように実装し実験するか？」といった問いにも対応できます。

SDDは要件変更を障害から通常のワークフローへと変えます。仕様が実装を駆動する場合、ピボットは手動の書き換えではなく体系的な再生成となります。PRDのコア要件を変更すれば、影響を受ける実装計画が自動的に更新されます。ユーザーストーリーを修正すれば、対応するAPIエンドポイントも再生成されます。これは初期開発だけでなく、不可避な変化の中でエンジニアリングの速度を維持するためのものです。


## コア原則


**仕様を共通言語に**：仕様が主たる成果物となり、コードは特定の言語やフレームワークでの表現となります。ソフトウェアの保守とは仕様の進化を意味します。

**実行可能な仕様**：仕様は動作するシステムを生成できるほど精密・完全・曖昧さがないものでなければなりません。これにより意図と実装のギャップが消えます。

**継続的な洗練**：一貫性の検証は一度きりのゲートではなく継続的に行われます。AIが仕様の曖昧さ・矛盾・ギャップを継続的に分析します。

**リサーチ駆動のコンテキスト**：リサーチエージェントが仕様作成プロセス全体で重要なコンテキストを収集し、技術的選択肢・パフォーマンス・組織的制約を調査します。

**双方向フィードバック**：運用現実が仕様進化を促します。メトリクス、インシデント、運用からの学びが仕様改善のインプットとなります。

**探索のための分岐**：同じ仕様から複数の実装アプローチを生成し、パフォーマンス・保守性・ユーザー体験・コストなど異なる最適化目標を探ります。


## 実践アプローチ


今日、SDDを実践するには既存ツールを組み合わせ、プロセス全体で規律を保つ必要があります。主な実践方法は以下の通りです：

- 反復的な仕様作成のためのAIアシスタント
- 技術的コンテキスト収集のためのリサーチエージェント
- 仕様から実装への変換を行うコード生成ツール
- 仕様ファーストなワークフローに適応したバージョン管理システム
- 仕様文書のAIによる一貫性チェック

重要なのは、仕様をソース・オブ・トゥルースとし、コードは仕様に従う生成物であると位置づけることです。


## ClaudeコマンドによるSDDの効率化


SDDの手法は、仕様作成と計画ワークフローを自動化する2つの強力なClaudeコマンドによって大幅に強化されます：

### `new_feature` コマンド

このコマンドは、シンプルな機能説明（ユーザープロンプト）を完全かつ構造化された仕様に変換し、リポジトリ管理も自動化します：

1. **自動機能ナンバリング**：既存の仕様をスキャンし、次の機能番号（例：001, 002, 003）を決定
2. **ブランチ作成**：説明からセマンティックなブランチ名を生成し、自動的に作成
3. **テンプレート生成**：機能仕様テンプレートをコピーし、要件に合わせてカスタマイズ
4. **ディレクトリ構造**：関連文書用に `specs/[branch-name]/` 構造を作成

### `generate_plan` コマンド

機能仕様が存在すれば、このコマンドで包括的な実装計画を作成します：

1. **仕様分析**：機能要件、ユーザーストーリー、受け入れ基準を読み取り理解
2. **憲法準拠**：プロジェクト憲法とアーキテクチャ原則との整合性を確保
3. **技術変換**：ビジネス要件を技術アーキテクチャと実装詳細に変換
4. **詳細ドキュメント**：データモデル、API契約、テストシナリオの補助文書を生成
5. **手動テスト計画**：各ユーザーストーリーの検証手順を作成

### 例：チャット機能の構築

これらのコマンドが従来の開発ワークフローをどう変えるか：

**従来のアプローチ：**
```
1. PRDを文書で作成（2-3時間）
2. 設計ドキュメント作成（2-3時間）
3. プロジェクト構造を手動でセットアップ（30分）
4. 技術仕様作成（3-4時間）
5. テスト計画作成（2時間）
合計：約12時間のドキュメント作業
```

**コマンドによるSDDアプローチ：**
```bash
# ステップ1：機能仕様を作成（5分）
/new_feature メッセージ履歴とユーザー在席表示付きリアルタイムチャットシステム

# これにより自動的に：
# - ブランチ「003-chat-system」を作成
# - specs/003-chat-system/feature-spec.mdを生成
# - 構造化された要件で埋める

# ステップ2：実装計画を生成（10分）
/generate_plan WebSocketによるリアルタイム通信、履歴用PostgreSQL、在席管理用Redis

# これにより自動的に：
# - specs/003-chat-system/implementation-plan.md
# - specs/003-chat-system/implementation-details/
#   - 00-research.md（WebSocketライブラリ比較）
#   - 02-data-model.md（メッセージ・ユーザースキーマ）
#   - 03-api-contracts.md（WebSocketイベント、RESTエンドポイント）
#   - 06-contract-tests.md（メッセージフローシナリオ）
#   - 08-inter-library-tests.md（DB-WebSocket連携）
# - specs/003-chat-system/manual-testing.md
```

15分で以下が揃います：
- ユーザーストーリーと受け入れ基準を含む完全な機能仕様
- 技術選定と根拠を含む詳細な実装計画
- コード生成に備えたAPI契約とデータモデル
- 自動・手動テスト両方の包括的なテストシナリオ
- すべての文書が機能ブランチで適切にバージョン管理

### 構造化自動化の力

これらのコマンドは単に時間を節約するだけでなく、一貫性と完全性を強制します：

1. **抜け漏れ防止**：テンプレートにより非機能要件からエラーハンドリングまで全て考慮
2. **決定のトレーサビリティ**：すべての技術選定が特定の要件に紐付く
3. **生きたドキュメント**：仕様がコードを生成するため常に同期
4. **迅速な反復**：要件変更から計画再生成まで数分で完了

これらのコマンドは、仕様を静的文書ではなく実行可能な成果物として扱うことでSDDの原則を体現します。仕様作成プロセスを「必要悪」から開発の推進力へと変革します。


### テンプレート駆動の品質：構造がLLMを制約し高品質を生む仕組み


これらのコマンドの真の力は自動化だけでなく、テンプレートがLLMの振る舞いを高品質な仕様へと導く点にあります。テンプレートはLLMの出力を生産的に制約する高度なプロンプトとして機能します：

#### 1. **早すぎる実装詳細の防止**

機能仕様テンプレートは明確に指示します：
```
- ✅ ユーザーが何を必要とし、なぜ必要かに集中
- ❌ どう実装するか（技術スタック、API、コード構造）は避ける
```

この制約により、LLMは適切な抽象度を維持します。たとえば「ReactとReduxで実装」と飛躍しがちなLLMも、「ユーザーはデータのリアルタイム更新を必要とする」に留めることができます。この分離により、実装技術が変わっても仕様は安定します。

#### 2. **明示的な不明点マーカーの強制**

両テンプレートは `[NEEDS CLARIFICATION]` マーカーの使用を義務付けます：
```
ユーザープロンプトから仕様を作成する際：
1. **すべての曖昧さをマーク**：[NEEDS CLARIFICATION: 具体的な質問] を使う
2. **推測しない**：プロンプトに明記されていない場合はマークする
```

これにより、LLMがもっともらしいが誤った推測をするのを防ぎます。たとえば「ログインシステムはメール/パスワード認証」と勝手に決めず、`[NEEDS CLARIFICATION: 認証方式未指定 - メール/パスワード、SSO、OAuth?]` と明記させます。

#### 3. **チェックリストによる構造的思考**

テンプレートには仕様の「単体テスト」として機能する包括的なチェックリストが含まれます：
```
### 要件の完全性
- [ ] [NEEDS CLARIFICATION] マーカーが残っていない
- [ ] 要件がテスト可能かつ曖昧でない
- [ ] 成功基準が測定可能
```

これによりLLMは体系的に自己レビューし、見落としを防ぎます。LLMに品質保証フレームワークを与えるようなものです。

#### 4. **ゲートによる憲法準拠**

実装計画テンプレートはフェーズゲートを通じてアーキテクチャ原則を強制します：
```
### フェーズ-1：事前実装ゲート
#### シンプリシティゲート（第VII条）
- [ ] 3プロジェクト以下？
- [ ] 先回り実装なし？
#### 反抽象化ゲート（第VIII条）
- [ ] フレームワークを直接利用？
- [ ] 単一モデル表現？
```

これらのゲートにより、LLMは複雑さを明示的に正当化しなければならず、ゲートを通過できない場合は「複雑性トラッキング」セクションで理由を文書化します。

#### 5. **階層的な詳細管理**

テンプレートは適切な情報構造を強制します：
```
**重要**：この実装計画は高レベルかつ可読性を保つこと。
コードサンプルや詳細なアルゴリズム、技術仕様は `implementation-details/` に分離すること
```

これにより、仕様が読めないコードの塊になるのを防ぎます。LLMは適切な詳細レベルを維持し、複雑さを分離ファイルに抽出しつつ、メイン文書の可読性を保ちます。

#### 6. **テストファースト思考**

実装テンプレートはテストファースト開発を強制します：
```
### ファイル作成順
1. API仕様を含む `contracts/` を作成
2. テストファイルを順に作成：契約→統合→E2E→単体
3. テストを通すためのソースファイル作成
```

この順序制約により、LLMは実装前にテスト性や契約を考慮し、より堅牢で検証可能な仕様を生み出します。

#### 7. **投機的機能の防止**

テンプレートは投機的な機能を明確に禁止します：
```
- [ ] 投機的または「必要かも」な機能なし
- [ ] すべてのフェーズに明確な前提条件と成果物
```

これにより、LLMが実装を複雑にする「あると便利」機能を追加するのを防ぎます。すべての機能は具体的なユーザーストーリーと明確な受け入れ基準に紐付く必要があります。

### 複合効果

これらの制約が組み合わさることで、以下のような仕様が生まれます：
- **完全性**：チェックリストで抜け漏れなし
- **曖昧さ排除**：明示的な不明点マーカー
- **テスト可能性**：テストファースト思考が組み込まれる
- **保守性**：適切な抽象度と情報構造
- **実装可能性**：明確なフェーズと具体的な成果物

テンプレートはLLMを創作家から規律ある仕様エンジニアへと変え、一貫して高品質かつ実行可能な仕様を生み出す力を引き出します。


## 憲法的基盤：アーキテクチャ規律の強制


SDDの中心には「憲法」があります。これは仕様がどのようにコードへと変換されるかを規定する不変の原則群です。憲法（`base/memory/constitution.md`）はシステムのアーキテクチャDNAとして機能し、すべての生成実装が一貫性・シンプルさ・品質を維持することを保証します。

### 開発の9つの条項

憲法は開発プロセスのあらゆる側面を形作る9つの条項を定めています：

#### 第I条：ライブラリファースト原則
すべての機能は必ず独立したライブラリとして始めなければなりません。例外はありません：
```
Specifyのすべての機能は、必ず独立したライブラリとして存在を開始しなければならない。
ライブラリコンポーネントへの抽象化なしに、アプリケーションコード内に直接実装してはならない。
```

この原則により、仕様はモノリシックなアプリではなく、モジュール化・再利用可能なコードを生成します。LLMが実装計画を生成する際は、機能を明確な境界と最小限の依存関係を持つライブラリとして構成しなければなりません。

#### 第II条：CLIインターフェース義務
すべてのライブラリはCLI（コマンドラインインターフェース）で機能を公開しなければなりません：
```
すべてのCLIインターフェースは：
- テキスト入力（stdin、引数、ファイル）を受け付ける
- テキスト出力（stdout）を生成する
- 構造化データ交換のためJSON形式をサポートする
```

これにより可観測性とテスト容易性が担保されます。LLMは機能を不透明なクラス内に隠すことはできず、すべてCLI経由でアクセス・検証可能でなければなりません。

#### 第III条：テストファーストの絶対命令
最も革新的な条項—テストより先にコードを書いてはならない：
```
これは絶対遵守事項：すべての実装は厳格なテスト駆動開発に従わなければならない。
実装コードは以下の前に書いてはならない：
1. 単体テストが作成されている
2. テストがユーザーにより承認されている
3. テストが失敗（Redフェーズ）であることが確認されている
```

これにより、従来のAIコード生成が完全に逆転します。コードを生成して動作を期待するのではなく、まず包括的なテストを生成し、承認を得てから実装を生成します。

#### 第VII・VIII条：シンプルさと反抽象化
この2つの条項は過剰設計を防ぎます：
```
第7.3節：最小プロジェクト構造
- 初期実装は最大3プロジェクトまで
- 追加プロジェクトは文書化された正当化が必要

第8.1節：フレームワーク信頼
- ラップせずフレームワーク機能を直接利用する
```

LLMが複雑な抽象化を作りがちな場合も、これらの条項により各レイヤーの複雑さを明示的に正当化させます。実装計画テンプレートの「フェーズ-1ゲート」がこれらの原則を直接強制します。

#### 第IX条：統合ファーストテスト
単体テストより現実的な環境でのテストを優先します：
```
テストは現実的な環境で行うこと：
- モックより実DBを優先
- スタブより実サービスインスタンスを優先
- 実装前に契約テスト必須
```

これにより、生成されたコードが理論上だけでなく実際に動作することが保証されます。

### テンプレートによる憲法強制

実装計画テンプレートは、これらの条項を具体的なチェックポイントとして運用化します：
```markdown
### フェーズ-1：事前実装ゲート
#### シンプリシティゲート（第VII条）
- [ ] 3プロジェクト以下？
- [ ] 先回り実装なし？

#### 反抽象化ゲート（第VIII条）
- [ ] フレームワークを直接利用？
- [ ] 単一モデル表現？

#### 統合ファーストゲート（第IX条）
- [ ] 契約定義済み？
- [ ] 契約テスト作成済み？
```

これらのゲートはアーキテクチャ原則のコンパイル時チェックとして機能します。LLMはゲートを通過するか、「複雑性トラッキング」セクションで正当な例外を文書化しない限り先に進めません。

### 不変原則の力

憲法の力はその不変性にあります。実装詳細は進化しても、コア原則は常に一定です。これにより：

1. **時を超えた一貫性**：今日生成したコードも来年生成したコードも同じ原則に従う
2. **LLM間の一貫性**：異なるAIモデルでもアーキテクチャ互換なコードを生成
3. **アーキテクチャの一体性**：すべての機能がシステム設計を強化
4. **品質保証**：テストファースト・ライブラリファースト・シンプルさ原則で保守性を担保

### 憲法の進化

原則は不変ですが、その適用は進化可能です：
```
第4.2節：改正プロセス
憲法の変更には：
- 変更理由の明示的な文書化
- プロジェクトメンテナによるレビューと承認
- 後方互換性の評価
```

これにより、手法は安定性を保ちつつ学習・改善できます。憲法自体も日付付きの改正履歴で進化を示し、原則が実体験に基づき洗練される様子を示します。

### ルールを超えて：開発哲学

憲法は単なるルールブックではなく、LLMのコード生成思考を形作る哲学です：

- **可観測性重視**：すべてCLI経由で検査可能でなければならない
- **シンプルさ重視**：まずシンプルに、必要が証明された場合のみ複雑さを追加
- **統合重視**：人工的な環境より現実環境でテスト
- **モジュール性重視**：すべての機能は明確な境界を持つライブラリ

これらの原則を仕様・計画プロセスに組み込むことで、SDDは生成コードが単に動作するだけでなく、保守性・テスト容易性・アーキテクチャ健全性を備えることを保証します。憲法はAIを単なるコード生成器から、システム設計原則を尊重・強化するアーキテクチャパートナーへと変貌させます。


## 変革

これは開発者を置き換えたり創造性を自動化するものではありません。機械的な変換を自動化することで人間の能力を拡張するものです。仕様・リサーチ・コードが共に進化し、各イテレーションで意図と実装の整合性・理解が深まるタイトなフィードバックループを作ることが目的です。

ソフトウェア開発には、意図と実装の整合性を維持するためのより良いツールが必要です。SDDは、単にガイドするだけでなくコードを生成する実行可能な仕様を通じて、この整合性を実現する方法論を提供します。
